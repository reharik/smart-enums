{"version":3,"sources":["../src/index.ts","../src/enumeration.ts","../src/types.ts","../src/extensionMethods.ts"],"sourcesContent":["export { enumeration } from './enumeration.js';\nexport type {\n  Enumeration,\n  DropdownOption,\n  EnumItem,\n  BaseEnum,\n} from './types.js';\n","import { capitalCase, constantCase } from 'case-anything';\n\nimport { addExtensionMethods } from './extensionMethods.js';\nimport {\n  BaseEnum,\n  EnumerationProps,\n  EnumItem,\n  ExtensionMethods,\n  NormalizedInputType,\n  PropertyAutoFormatter,\n} from './types.js';\n\n/**\n * Creates a type-safe enumeration with built-in utility methods.\n *\n * @example\n * // Simple string array input\n * const Status = enumeration({\n *   input: ['PENDING', 'ACTIVE', 'COMPLETED'] as const\n * });\n *\n * // Object input with overrides\n * const UserRole = enumeration({\n *   input: {\n *     ADMIN: { display: 'Administrator', value: 'admin' },\n *     USER: { display: 'Regular User' },\n *     GUEST: { deprecated: true }\n *   }\n * });\n *\n * // With custom extensions\n * const Priority = enumeration({\n *   input: {\n *     LOW: { level: 1 },\n *     MEDIUM: { level: 2 },\n *     HIGH: { level: 3 }\n *   },\n *   extraExtensionMethods: (items) => ({\n *     getByLevel: (level: number) => items.find(i => i.level === level),\n *     getSorted: () => items.sort((a, b) => a.level - b.level)\n *   })\n * });\n *\n * // Usage examples:\n * const active = Status.ACTIVE; // EnumItem with key, value, display, etc.\n * const statusFromValue = Status.fromValue('PENDING'); // Lookup by value\n * const allOptions = Status.toOptions(); // Convert to dropdown options\n * const activeOnly = UserRole.toEnumItems(item => !item.deprecated);\n *\n * @param props Configuration for the enumeration\n * @returns An object with enum items as properties plus all extension methods\n */\nfunction enumeration<\n  TInput extends readonly string[] | { [k: string]: BaseEnum },\n  TEnumItemExtension = Record<string, never>,\n  TExtraExtensionMethods = Record<string, never>,\n>({\n  input,\n  extraExtensionMethods,\n  propertyAutoFormatters,\n}: EnumerationProps<TInput, TEnumItemExtension, TExtraExtensionMethods>): {\n  [K in keyof NormalizedInputType<TInput>]: EnumItem<\n    NormalizedInputType<TInput>,\n    TEnumItemExtension\n  >;\n} & ExtensionMethods<NormalizedInputType<TInput>, TEnumItemExtension> &\n  TExtraExtensionMethods {\n  // Step 1: Normalize input to object format\n  // Arrays become objects with empty values: ['A', 'B'] -> { A: {}, B: {} }\n  const normalizedInput: NormalizedInputType<TInput> = (\n    Array.isArray(input)\n      ? input.reduce(\n          (acc: NormalizedInputType<TInput>, k) => ({ ...acc, [k]: {} }),\n          {},\n        )\n      : input\n  ) as NormalizedInputType<TInput>;\n\n  // Step 2: Set up property formatters with defaults\n  // By default: value = CONSTANT_CASE, display = Capital Case\n  const formattersWithDefaults = [\n    { key: 'value', format: constantCase },\n    { key: 'display', format: capitalCase },\n    ...(propertyAutoFormatters || []),\n  ];\n\n  // Helper to apply all formatters to a key\n  const formatProperties = (k: string, formatters: PropertyAutoFormatter[]) =>\n    formatters.reduce((acc: Record<string, string>, formatter) => {\n      acc[formatter.key] = formatter.format(k);\n      return acc;\n    }, {});\n\n  // Step 3: Build the enum items object\n  const rawEnumItems: {\n    [K in keyof NormalizedInputType<TInput>]: EnumItem<\n      NormalizedInputType<TInput>,\n      TEnumItemExtension\n    >;\n  } = {} as {\n    [K in keyof NormalizedInputType<TInput>]: EnumItem<\n      NormalizedInputType<TInput>,\n      TEnumItemExtension\n    >;\n  };\n\n  // Step 4: Populate each enum item with formatted properties and user overrides\n  let index = 0;\n  for (const key in normalizedInput) {\n    // eslint requires hasOwnProperty check\n    if (Object.prototype.hasOwnProperty.call(normalizedInput, key)) {\n      const value = normalizedInput[key];\n\n      // Create enum item:\n      // 1. Set index and key\n      // 2. Apply auto-formatters (value, display, custom)\n      // 3. Override with any user-provided values\n      const enumItem: EnumItem<\n        NormalizedInputType<TInput>,\n        TEnumItemExtension\n      > = {\n        index,\n        key: key as keyof NormalizedInputType<TInput>,\n        ...formatProperties(key, formattersWithDefaults), // Auto-generated props\n        ...value, // User overrides\n      } as EnumItem<NormalizedInputType<TInput>, TEnumItemExtension>;\n\n      rawEnumItems[key] = enumItem;\n      index++;\n    }\n  }\n\n  // Step 5: Combine enum items with extension methods\n  // This creates the final enum object with both data and methods\n  return {\n    ...rawEnumItems, // All enum items as properties\n    ...addExtensionMethods(Object.values(rawEnumItems), extraExtensionMethods), // All methods\n  };\n}\nexport { enumeration };\n","/**\n * Type guard to check if a value is not null or undefined\n * @param value - The value to check\n * @returns True if the value is defined and not null\n */\nexport const notEmpty = <X>(\n  value: X | null | undefined,\n): value is NonNullable<X> => {\n  // eslint-disable-next-line unicorn/no-null\n  return value != null;\n};\n\n/**\n * Base structure for enum items. All enum items will have these properties.\n */\nexport type BaseEnum = {\n  /** The constant-case value (e.g., \"USER_ADMIN\") */\n  value?: string;\n  /** The human-readable display name (e.g., \"User Admin\") */\n  display?: string;\n  /** The index/order of this item in the enum */\n  index?: number;\n  /** Whether this enum value is deprecated and should be hidden in most cases */\n  deprecated?: boolean;\n};\n\n/**\n * Configuration for creating an enumeration\n * @template TInput - Either a readonly string array or an object with BaseEnum values\n * @template TEnumItemExtension - Additional properties to add to each enum item\n * @template TExtraExtensionMethods - Additional methods to add to the enum object\n */\nexport type EnumerationProps<\n  TInput extends readonly string[] | { [k: string]: Partial<BaseEnum> },\n  TEnumItemExtension = Record<string, never>,\n  TExtraExtensionMethods = Record<string, never>,\n> = {\n  /**\n   * The input data for the enum. Can be:\n   * - An array of strings: ['USER', 'ADMIN']\n   * - An object with overrides: { USER: { display: 'User Account' }, ADMIN: { deprecated: true } }\n   */\n  input: TInput;\n\n  /**\n   * Factory function to add custom methods to the enum object.\n   * Receives all enum items and should return an object with the custom methods.\n   * @example\n   * extraExtensionMethods: (items) => ({\n   *   getActiveItems: () => items.filter(i => !i.deprecated),\n   *   findByRole: (role: string) => items.find(i => i.role === role)\n   * })\n   */\n  extraExtensionMethods?: (\n    enumItems: EnumItem<NormalizedInputType<TInput>, TEnumItemExtension>[],\n  ) => TExtraExtensionMethods;\n\n  /**\n   * Auto-formatters for generating additional properties from the key.\n   * By default, 'value' uses constantCase and 'display' uses capitalCase.\n   * @example\n   * propertyAutoFormatters: [\n   *   { key: 'slug', format: (k) => k.toLowerCase() },\n   *   { key: 'code', format: (k) => k.substring(0, 3) }\n   * ]\n   */\n  propertyAutoFormatters?: PropertyAutoFormatter[];\n};\n\n/**\n * Defines how to auto-generate a property from the enum key\n */\nexport type PropertyAutoFormatter = {\n  /** The property name to generate */\n  key: string;\n  /** Function to transform the key into the property value */\n  format: (k: string) => string;\n};\n\n/**\n * Options for filtering enum items in various methods\n */\nexport type EnumFilterOptions = {\n  /** Include items with null/undefined values (default: false) */\n  showEmpty?: boolean;\n  /** Include deprecated items (default: false) */\n  showDeprecated?: boolean;\n};\n\n/**\n * Standard dropdown/select option format\n */\nexport type DropdownOption = {\n  value: string;\n  label: string;\n  iconText?: string;\n};\n\n/**\n * All extension methods that are automatically added to enum objects.\n * These methods provide various ways to look up and filter enum items.\n */\nexport type ExtensionMethods<T, TEnumItemExtension> = {\n  /** Get enum item by its value. Throws if not found. */\n  fromValue: (target: string) => EnumItem<T, TEnumItemExtension>;\n\n  /** Get enum item by its key. Throws if not found. */\n  fromKey: (target: string) => EnumItem<T, TEnumItemExtension>;\n\n  /** Get enum item by its display text. Throws if not found. */\n  fromDisplay: (target: string) => EnumItem<T, TEnumItemExtension>;\n\n  /** Get enum item by its value. Returns undefined if not found. */\n  tryFromValue: (\n    target?: string | null,\n  ) => EnumItem<T, TEnumItemExtension> | undefined;\n\n  /** Get enum item by its key. Returns undefined if not found. */\n  tryFromKey: (\n    target?: string | null,\n  ) => EnumItem<T, TEnumItemExtension> | undefined;\n\n  /**\n   * Get enum item by any custom field. Returns undefined if not found.\n   * @example\n   * MyEnum.tryFromCustomField('role', 'admin', item => !item.deprecated)\n   */\n  tryFromCustomField: (\n    field: keyof TEnumItemExtension,\n    target?: string | null,\n    filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n  ) => EnumItem<T, TEnumItemExtension> | undefined;\n\n  /** Get enum item by its display text. Returns undefined if not found. */\n  tryFromDisplay: (\n    target?: string | null,\n  ) => EnumItem<T, TEnumItemExtension> | undefined;\n\n  /**\n   * Extract values from a custom field across all enum items\n   * @example\n   * const roles = MyEnum.toCustomFieldValues<string>('role', item => item.active)\n   */\n  toCustomFieldValues: <X = string>(\n    field: keyof TEnumItemExtension,\n    filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => X[];\n\n  /** Convert enum items to dropdown options, sorted by index */\n  toOptions: (\n    filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => DropdownOption[];\n\n  /** Get all enum values as an array */\n  toValues: (\n    filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => string[];\n\n  /** Get all enum keys as an array */\n  toKeys: (\n    filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => string[];\n\n  /** Get all display values as an array */\n  toDisplays: (\n    filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => string[];\n\n  /** Get all enum items as an array (useful for iteration) */\n  toEnumItems: (\n    filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => EnumItem<T, TEnumItemExtension>[];\n\n  /**\n   * Convert to an object keyed by enum keys.\n   * Useful for creating subsets or filtered versions of the enum.\n   */\n  toExtendableObject: <ITEM_TYPE extends BaseEnum>(\n    filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => Record<string, ITEM_TYPE>;\n};\n\n/**\n * Converts a readonly string array type to an object type with BaseEnum values\n * @internal\n */\nexport type ArrayToObjectType<T extends readonly string[]> = {\n  [K in T[number]]: BaseEnum;\n};\n\n/**\n * Normalizes the input type to always be an object format.\n * String arrays are converted to objects with empty BaseEnum values.\n * @internal\n */\nexport type NormalizedInputType<T> = T extends readonly string[]\n  ? ArrayToObjectType<T>\n  : T extends { [k: string]: BaseEnum }\n    ? T\n    : never;\n\n/**\n * The structure of each item in an enumeration.\n * Combines BaseEnum properties with any custom extensions.\n */\nexport type EnumItem<\n  T,\n  TEnumItemExtension = Record<string, never>,\n  K extends keyof NormalizedInputType<T> = keyof NormalizedInputType<T>,\n> = {\n  /** The original key from the input (e.g., 'USER_ADMIN') */\n  key: K;\n  value: string;\n  display?: string;\n  index?: number;\n  deprecated?: boolean;\n} & TEnumItemExtension;\n\n/**\n * Helper type for extracting the enum type from an enumeration object\n */\nexport type Enumeration<ENUM_OF, INPUT_TYPE> = EnumItem<INPUT_TYPE> &\n  Omit<\n    ENUM_OF[keyof ENUM_OF & keyof NormalizedInputType<INPUT_TYPE>],\n    'key' | 'value' | 'display' | 'index' | 'deprecated'\n  >;\n","import {\n  DropdownOption,\n  BaseEnum,\n  EnumFilterOptions,\n  EnumItem,\n  ExtensionMethods,\n  notEmpty,\n} from './types.js';\n\n/**\n * Adds extension methods to an enum object.\n * This is the main factory that creates all the utility methods for enum lookup and filtering.\n *\n * @param enumItems - Array of all enum items\n * @param extraExtensionMethods - Optional factory for additional custom methods\n * @returns An object containing all standard extension methods plus any custom methods\n */\n\nexport const addExtensionMethods = <\n  T,\n  TEnumItemExtension = Record<string, never>,\n  TExtraExtensionMethods = Record<string, never>,\n>(\n  enumItems: EnumItem<T, TEnumItemExtension>[],\n  extraExtensionMethods?: (\n    enumItems: EnumItem<T, TEnumItemExtension>[],\n  ) => TExtraExtensionMethods,\n) => {\n  const extensionMethods = buildExtensionMethods<T, TEnumItemExtension>(\n    enumItems,\n  );\n  let extra = {} as TExtraExtensionMethods;\n  if (extraExtensionMethods) {\n    extra = extraExtensionMethods(enumItems);\n  }\n  return { ...extensionMethods, ...extra };\n};\n\n/**\n * Builds all standard extension methods for enum objects.\n * These methods provide various ways to look up, filter, and transform enum items.\n *\n * @internal\n */\nconst buildExtensionMethods = <T, TEnumItemExtension>(\n  rawEnum: EnumItem<T, TEnumItemExtension>[],\n): ExtensionMethods<T, TEnumItemExtension> => {\n  return {\n    // Lookup methods - these find enum items by different properties\n\n    fromValue: (target: string) => {\n      const item = Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.value === target,\n      );\n      if (!item) {\n        throw new Error(`No enum value found for '${target}'`);\n      }\n      return item;\n    },\n\n    tryFromValue: (target?: string | null) => {\n      if (!target) {\n        return;\n      }\n      return Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.value === target,\n      );\n    },\n\n    fromKey: (target: string) => {\n      const item = Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.key === target,\n      );\n      if (!item) {\n        throw new Error(`No enum key found for '${target}'`);\n      }\n      return item;\n    },\n\n    tryFromKey: (target?: string | null) => {\n      if (!target) {\n        return;\n      }\n      return Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.key === target,\n      );\n    },\n\n    /**\n     * Flexible lookup by any custom field.\n     * Useful when enum items have additional properties beyond the standard ones.\n     */\n    tryFromCustomField: (\n      field: keyof EnumItem<T, TEnumItemExtension>,\n      target?: string | null,\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n    ) => {\n      if (!target) {\n        return;\n      }\n      return (\n        Object.values(rawEnum)\n          // eslint-disable-next-line unicorn/no-array-callback-reference\n          .filter(filter || (() => true))\n          .find(\n            (value: EnumItem<T, TEnumItemExtension>) => value[field] === target,\n          )\n      );\n    },\n\n    fromDisplay: (target: string) => {\n      const item = Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.display === target,\n      );\n      if (!item) {\n        throw new Error(`No enum display found for '${target}'`);\n      }\n      return item;\n    },\n\n    tryFromDisplay: (target?: string | null) => {\n      if (!target) {\n        return;\n      }\n      return Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.display === target,\n      );\n    },\n\n    // Transformation methods - these convert enum items to different formats\n\n    /**\n     * Extract values from a specific custom field across all items.\n     * Respects filter options for empty and deprecated items.\n     */\n    toCustomFieldValues: <CustomFieldType = string>(\n      field: keyof TEnumItemExtension,\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) => {\n      return Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty\n              ? true\n              : notEmpty(x[field] as CustomFieldType)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map(x => x[field] as CustomFieldType);\n    },\n\n    /**\n     * Convert to dropdown options, automatically sorted by index.\n     * Includes optional iconText if present in the enum item.\n     */\n    toOptions: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ): DropdownOption[] => {\n      return [\n        ...((rawEnum as (EnumItem<T, TEnumItemExtension> & {\n          iconText?: string;\n        })[]) || []),\n      ]\n        .sort(\n          (\n            a: EnumItem<T, TEnumItemExtension>,\n            b: EnumItem<T, TEnumItemExtension>,\n          ) => (a?.index && b?.index ? (a?.index || 0) - (b?.index || 0) : 0),\n        )\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map(item => ({\n          label: item.display || (item.key as string),\n          value: item.value,\n          ...(item.iconText ? { iconText: item.iconText } : {}),\n        }));\n    },\n\n    // Array extraction methods - these get arrays of specific properties\n\n    toValues: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) =>\n      Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map((item: EnumItem<T, TEnumItemExtension>) => item.value),\n\n    toKeys: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) =>\n      Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map((item: EnumItem<T, TEnumItemExtension>) => item.key) as string[],\n\n    toDisplays: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) =>\n      Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map(\n          (item: EnumItem<T, TEnumItemExtension>) => item.display,\n        ) as string[],\n\n    toEnumItems: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) =>\n      Object.values(rawEnum).filter(\n        x =>\n          (filter ? filter(x) : true) &&\n          (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n          (filterOptions?.showDeprecated ? true : !x.deprecated),\n      ),\n\n    /**\n     * Creates a new object with filtered enum items.\n     * Useful for creating subset enums or when you need an object format.\n     */\n    toExtendableObject: <ITEM_TYPE extends BaseEnum>(\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) => {\n      type ExtObject = Record<string, ITEM_TYPE>;\n      return Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .reduce((acc: ExtObject, item) => {\n          acc[item.key as keyof ExtObject] = item as unknown as ITEM_TYPE;\n          return acc;\n        }, {} as ExtObject);\n    },\n  };\n};\n"],"mappings":"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","names":[]}