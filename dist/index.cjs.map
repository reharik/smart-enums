{"version":3,"sources":["../src/index.ts","../src/enumeration.ts","../src/types.ts","../src/extensionMethods.ts","../src/utilities/transformation.ts"],"sourcesContent":["export { enumeration, isSmartEnumItem } from './enumeration.js';\nexport {\n  serializeSmartEnums,\n  reviveSmartEnums,\n} from './utilities/transformation.js';\nexport type {\n  Enumeration,\n  DropdownOption,\n  EnumItem,\n  BaseEnum,\n  EnumItemType,\n} from './types.js';\n","import { capitalCase, constantCase } from 'case-anything';\n\nimport { addExtensionMethods } from './extensionMethods.js';\nimport {\n  EnumerationProps,\n  EnumItem,\n  ExtensionMethods,\n  NormalizedInputType,\n  PropertyAutoFormatter,\n  EnumInput,\n  ObjectEnumInput,\n  ArrayToObjectType,\n  SMART_ENUM_ITEM,\n  SMART_ENUM_ID,\n} from './types.js';\n\n/**\n * Runtime type guard to detect Smart Enum items created by this library.\n */\nexport const isSmartEnumItem = (\n  x: unknown,\n): x is { key: string; value: string; index?: number } => {\n  return (\n    !!x && typeof x === 'object' && Reflect.get(x, SMART_ENUM_ITEM) === true\n  );\n};\n\n// Overload 1: array input (types return object form)\nexport function enumeration<\n  TArr extends readonly string[],\n  TEnumItemExtension = Record<string, never>,\n  TExtraExtensionMethods = Record<string, never>,\n>(\n  props: EnumerationProps<TArr, TEnumItemExtension, TExtraExtensionMethods>,\n): {\n  [K in keyof ArrayToObjectType<TArr>]: EnumItem<\n    ArrayToObjectType<TArr>,\n    TEnumItemExtension\n  >;\n} & ExtensionMethods<\n  {\n    [K in keyof ArrayToObjectType<TArr>]: EnumItem<\n      ArrayToObjectType<TArr>,\n      TEnumItemExtension\n    >;\n  },\n  TEnumItemExtension\n> &\n  TExtraExtensionMethods;\n\n// Overload 2: object input\nexport function enumeration<\n  TObj extends ObjectEnumInput,\n  TEnumItemExtension = Record<string, never>,\n  TExtraExtensionMethods = Record<string, never>,\n>(\n  props: EnumerationProps<TObj, TEnumItemExtension, TExtraExtensionMethods>,\n): {\n  [K in keyof TObj]: EnumItem<TObj, TEnumItemExtension>;\n} & ExtensionMethods<\n  {\n    [K in keyof TObj]: EnumItem<TObj, TEnumItemExtension>;\n  },\n  TEnumItemExtension\n> &\n  TExtraExtensionMethods;\n\n// Implementation\nexport function enumeration<\n  TInput extends EnumInput,\n  TEnumItemExtension = Record<string, never>,\n  TExtraExtensionMethods = Record<string, never>,\n>({\n  input,\n  extraExtensionMethods,\n  propertyAutoFormatters,\n  enumType,\n}: EnumerationProps<TInput, TEnumItemExtension, TExtraExtensionMethods>): {\n  [K in keyof NormalizedInputType<TInput>]: EnumItem<\n    NormalizedInputType<TInput>,\n    TEnumItemExtension\n  >;\n} & ExtensionMethods<\n  {\n    [K in keyof NormalizedInputType<TInput>]: EnumItem<\n      NormalizedInputType<TInput>,\n      TEnumItemExtension\n    >;\n  },\n  TEnumItemExtension\n> &\n  TExtraExtensionMethods {\n  // Step 1: Normalize input to object format\n  // Arrays become objects with empty values: ['A', 'B'] -> { A: {}, B: {} }\n  const normalizedInput: NormalizedInputType<TInput> = (\n    Array.isArray(input)\n      ? input.reduce(\n          (acc: NormalizedInputType<TInput>, k) => ({ ...acc, [k]: {} }),\n          {},\n        )\n      : input\n  ) as NormalizedInputType<TInput>;\n\n  // Step 2: Set up property formatters with defaults\n  // By default: value = CONSTANT_CASE, display = Capital Case\n  const formattersWithDefaults = [\n    { key: 'value', format: constantCase },\n    { key: 'display', format: capitalCase },\n    ...(propertyAutoFormatters || []),\n  ];\n\n  // Helper to apply all formatters to a key\n  const formatProperties = (k: string, formatters: PropertyAutoFormatter[]) =>\n    formatters.reduce((acc: Record<string, string>, formatter) => {\n      acc[formatter.key] = formatter.format(k);\n      return acc;\n    }, {});\n\n  // Step 3: Build the enum items object\n  const rawEnumItems: {\n    [K in keyof NormalizedInputType<TInput>]: EnumItem<\n      NormalizedInputType<TInput>,\n      TEnumItemExtension\n    >;\n  } = {} as {\n    [K in keyof NormalizedInputType<TInput>]: EnumItem<\n      NormalizedInputType<TInput>,\n      TEnumItemExtension\n    >;\n  };\n\n  // Step 4: Populate each enum item with formatted properties and user overrides\n  // Create a per-enum instance identifier for optional identity checks\n  const enumInstanceId = Symbol('smart-enum-instance');\n  let index = 0;\n  for (const key in normalizedInput) {\n    // eslint requires hasOwnProperty check\n    if (Object.prototype.hasOwnProperty.call(normalizedInput, key)) {\n      const value = normalizedInput[key];\n\n      // Create enum item:\n      // 1. Set index and key\n      // 2. Apply auto-formatters (value, display, custom)\n      // 3. Override with any user-provided values\n      const enumItem: EnumItem<\n        NormalizedInputType<TInput>,\n        TEnumItemExtension\n      > = {\n        index,\n        key: key as keyof NormalizedInputType<TInput>,\n        ...formatProperties(key, formattersWithDefaults), // Auto-generated props\n        ...value, // User overrides\n        __smart_enum_brand: true,\n      } as EnumItem<NormalizedInputType<TInput>, TEnumItemExtension>;\n\n      // Attach non-enumerable runtime tags for detection and identity\n      Object.defineProperty(enumItem, SMART_ENUM_ITEM, {\n        value: true,\n        enumerable: false,\n      });\n      Object.defineProperty(enumItem, SMART_ENUM_ID, {\n        value: enumInstanceId,\n        enumerable: false,\n      });\n\n      // If a public enumType was provided, attach a JSON serializer that emits it\n      // Attach toJSON only when an enumType is provided in the props\n      if (enumType) {\n        Object.defineProperty(enumItem, 'toJSON', {\n          value: () => ({ __smart_enum_type: enumType, value: enumItem.value }),\n        });\n      }\n\n      rawEnumItems[key] = enumItem;\n      index++;\n    }\n  }\n\n  // Step 5: Combine enum items with extension methods\n  // This creates the final enum object with both data and methods\n  return {\n    ...rawEnumItems, // All enum items as properties\n    ...addExtensionMethods(Object.values(rawEnumItems), extraExtensionMethods), // All methods\n  };\n}\n","/**\n * Type guard to check if a value is not null or undefined\n * @param value - The value to check\n * @returns True if the value is defined and not null\n */\nexport const notEmpty = <X>(\n  value: X | null | undefined,\n): value is NonNullable<X> => {\n  // eslint-disable-next-line unicorn/no-null\n  return value != null;\n};\n\n// Public symbols used at runtime for detection/identity (not used in type keys)\nexport const SMART_ENUM_ITEM = Symbol('smart-enum-item');\nexport const SMART_ENUM_ID = Symbol('smart-enum-id');\n\n/**\n * Base structure for enum items. All enum items will have these properties.\n */\nexport type BaseEnum = {\n  /** The constant-case value (e.g., \"USER_ADMIN\") */\n  value?: string;\n  /** The human-readable display name (e.g., \"User Admin\") */\n  display?: string;\n  /** The index/order of this item in the enum */\n  index?: number;\n  /** Whether this enum value is deprecated and should be hidden in most cases */\n  deprecated?: boolean;\n};\n\n/**\n * Configuration for creating an enumeration\n * @template TInput - Either a readonly string array or an object with BaseEnum values\n * @template TEnumItemExtension - Additional properties to add to each enum item\n * @template TExtraExtensionMethods - Additional methods to add to the enum object\n */\nexport type EnumerationProps<\n  TInput extends EnumInput,\n  TEnumItemExtension = Record<string, never>,\n  TExtraExtensionMethods = Record<string, never>,\n> = {\n  /**\n   * The input data for the enum. Can be:\n   * - An array of strings: ['USER', 'ADMIN']\n   * - An object with overrides: { USER: { display: 'User Account' }, ADMIN: { deprecated: true } }\n   */\n  input: TInput;\n\n  /**\n   * Factory function to add custom methods to the enum object.\n   * Receives all enum items and should return an object with the custom methods.\n   * @example\n   * extraExtensionMethods: (items) => ({\n   *   getActiveItems: () => items.filter(i => !i.deprecated),\n   *   findByRole: (role: string) => items.find(i => i.role === role)\n   * })\n   */\n  extraExtensionMethods?: (\n    enumItems: EnumItem<NormalizedInputType<TInput>, TEnumItemExtension>[],\n  ) => TExtraExtensionMethods;\n\n  /**\n   * Auto-formatters for generating additional properties from the enum key.\n   * By default, 'value' uses constantCase and 'display' uses capitalCase.\n   * @example\n   * propertyAutoFormatters: [\n   *   { key: 'slug', format: (k) => k.toLowerCase() },\n   *   { key: 'code', format: (k) => k.substring(0, 3) }\n   * ]\n   */\n  propertyAutoFormatters?: PropertyAutoFormatter[];\n\n  /**\n   * Optional identifier for this enum type. When provided, enum items will\n   * serialize with a toJSON() that includes this id so consumers can revive\n   * without an external field map. Example output: { __smart_enum_type: 'Status', value: 'ACTIVE' }\n   */\n  enumType?: string;\n};\n\n/**\n * Defines how to auto-generate a property from the enum key\n */\nexport type PropertyAutoFormatter = {\n  /** The property name to generate */\n  key: string;\n  /** Function to transform the key into the property value */\n  format: (k: string) => string;\n};\n\n/**\n * Options for filtering enum items in various methods\n */\nexport type EnumFilterOptions = {\n  /** Include items with null/undefined values (default: false) */\n  showEmpty?: boolean;\n  /** Include deprecated items (default: false) */\n  showDeprecated?: boolean;\n};\n\n/**\n * Standard dropdown/select option format\n */\nexport type DropdownOption = {\n  value: string;\n  label: string;\n  iconText?: string;\n};\n\n// Named input shapes for enumeration()\nexport type ObjectEnumInput = {\n  readonly [k: string]: Readonly<Partial<BaseEnum> & Record<string, unknown>>;\n};\nexport type EnumInput = readonly string[] | ObjectEnumInput;\n\n/**\n * All extension methods that are automatically added to enum objects.\n * These methods provide various ways to look up and filter enum items.\n */\nexport type ExtensionMethods<E, TEnumItemExtension> = {\n  /** Get enum item by its value. Throws if not found. */\n  fromValue: (target: string) => ItemOf<E>;\n\n  /** Get enum item by its key. Throws if not found. */\n  fromKey: (target: string) => ItemOf<E>;\n\n  /** Get enum item by its display text. Throws if not found. */\n  fromDisplay: (target: string) => ItemOf<E>;\n\n  /** Get enum item by its value. Returns undefined if not found. */\n  tryFromValue: (target?: string | null) => ItemOf<E> | undefined;\n\n  /** Get enum item by its key. Returns undefined if not found. */\n  tryFromKey: (target?: string | null) => ItemOf<E> | undefined;\n\n  /**\n   * Get enum item by any custom field. Returns undefined if not found.\n   * @example\n   * MyEnum.tryFromCustomField('role', 'admin', item => !item.deprecated)\n   */\n  tryFromCustomField: (\n    field: keyof TEnumItemExtension,\n    target?: string | null,\n    filter?: (item: ItemOf<E>) => boolean,\n  ) => ItemOf<E> | undefined;\n\n  /** Get enum item by its display text. Returns undefined if not found. */\n  tryFromDisplay: (target?: string | null) => ItemOf<E> | undefined;\n\n  /**\n   * Extract values from a custom field across all enum items\n   * @example\n   * const roles = MyEnum.toCustomFieldValues<string>('role', item => item.active)\n   */\n  toCustomFieldValues: <X = string>(\n    field: keyof TEnumItemExtension,\n    filter?: (item: ItemOf<E>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => X[];\n\n  /** Convert enum items to dropdown options, sorted by index */\n  toOptions: (\n    filter?: (item: ItemOf<E>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => DropdownOption[];\n\n  /** Get all enum values as an array */\n  toValues: (\n    filter?: (item: ItemOf<E>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => string[];\n\n  /** Get all enum keys as an array */\n  toKeys: (\n    filter?: (item: ItemOf<E>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => string[];\n\n  /** Get all display values as an array */\n  toDisplays: (\n    filter?: (item: ItemOf<E>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => string[];\n\n  /** Get all enum items as an array (useful for iteration) */\n  toEnumItems: (\n    filter?: (item: ItemOf<E>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => ItemOf<E>[];\n\n  /**\n   * Convert to an object keyed by enum keys.\n   * Useful for creating subsets or filtered versions of the enum.\n   */\n  toExtendableObject: <ITEM_TYPE extends BaseEnum>(\n    filter?: (item: ItemOf<E>) => boolean,\n    filterOptions?: EnumFilterOptions,\n  ) => Record<string, ITEM_TYPE>;\n};\n\n/**\n * Converts a readonly string array type to an object type with BaseEnum values\n * @internal\n */\nexport type ArrayToObjectType<T extends readonly string[]> = {\n  [K in T[number]]: BaseEnum;\n};\n\n/**\n * Normalizes the input type to always be an object format.\n * String arrays are converted to objects with empty BaseEnum values.\n * @internal\n */\nexport type NormalizedInputType<T> = T extends readonly string[]\n  ? ArrayToObjectType<T>\n  : T extends { readonly [k: string]: Readonly<Record<string, unknown>> }\n    ? T\n    : never;\n\n/**\n * The structure of each item in an enumeration.\n * Combines BaseEnum properties with any custom extensions.\n */\nexport type EnumItem<\n  T = unknown,\n  TEnumItemExtension = Record<string, never>,\n> = ({\n  /** The original key from the input (e.g., 'USER_ADMIN') */\n  key: string;\n  value: string;\n  display?: string;\n  index?: number;\n  deprecated?: boolean;\n  /** Type-level brand for filtering item members */\n  readonly __smart_enum_brand: true;\n} & TEnumItemExtension) & (T extends unknown ? object : never);\n\n\n/**\n * Union of all enum item variants for a given enum input type.\n */\nexport type EnumItemUnion<T, TEnumItemExtension = Record<string, never>> = {\n  [K in keyof NormalizedInputType<T>]: EnumItem<T, TEnumItemExtension>;\n}[keyof NormalizedInputType<T>];\n\n/** Public helper alias for consumers */\nexport type ItemOf<E> = E[keyof E];\n\n/**\n * Helper to get the enum item type from an enum object returned by enumeration().\n * Usage:\n *   const MyEnum = enumeration({ input });\n *   type MyEnumItem = EnumItemType<typeof MyEnum>;\n */\nexport type EnumItemType<TEnum extends Record<string, unknown>> = Extract<\n  TEnum[keyof TEnum],\n  { __smart_enum_brand: true }\n>;\n\n/**\n * Helper type for extracting the enum type from an enumeration object\n */\n// Back-compat alias: the item type of an enumeration object\n// Note: The second generic is ignored to avoid conflicts with item typing.\nexport type Enumeration<ENUM_OF extends Record<string, unknown>> = Extract<\n  ENUM_OF[keyof ENUM_OF],\n  { __smart_enum_brand: true }\n>;\n\n/**\n * Compile-time transformer: replaces Smart Enum items with string values,\n * recursively over arrays and objects. Structural detection checks for\n * presence of `key` and `value`.\n */\nexport type SerializedSmartEnums<T> = T extends { value: string; key: unknown }\n  ? string\n  : T extends ReadonlyArray<infer U>\n    ? ReadonlyArray<SerializedSmartEnums<U>>\n    : T extends Array<infer U>\n      ? SerializedSmartEnums<U>[]\n      : T extends object\n        ? { [K in keyof T]: SerializedSmartEnums<T[K]> }\n        : T;\n\n/**\n * Revived shape: for keys present in mapping M, the string becomes the\n * corresponding enum item type (derived from the provided enum object);\n * other fields recurse.\n */\nexport type EnumItemFromEnum<TEnum> =\n  TEnum extends Record<string, infer V>\n    ? V extends { value: string }\n      ? V\n      : never\n    : never;\n\n// Structural constraint for enum objects passed to reviveSmartEnums mapping\nexport type AnyEnumLike = {\n  tryFromValue: (value?: string | null) => { value: string } | undefined;\n} & Record<string, { value: string }>;\n\nexport type RevivedSmartEnums<T, M extends Record<string, AnyEnumLike>> =\n  T extends ReadonlyArray<infer U>\n    ? ReadonlyArray<RevivedSmartEnums<U, M>>\n    : T extends Array<infer U>\n      ? RevivedSmartEnums<U, M>[]\n      : T extends object\n        ? {\n            [K in keyof T]: K extends Extract<keyof M, string>\n              ? EnumItemFromEnum<M[K]>\n              : RevivedSmartEnums<T[K], M>;\n          }\n        : T;\n","import {\n  DropdownOption,\n  BaseEnum,\n  EnumFilterOptions,\n  EnumItem,\n  ExtensionMethods,\n  notEmpty,\n} from './types.js';\n\n/**\n * Adds extension methods to an enum object.\n * This is the main factory that creates all the utility methods for enum lookup and filtering.\n *\n * @param enumItems - Array of all enum items\n * @param extraExtensionMethods - Optional factory for additional custom methods\n * @returns An object containing all standard extension methods plus any custom methods\n */\n\nexport const addExtensionMethods = <\n  T,\n  TEnumItemExtension = Record<string, never>,\n  TExtraExtensionMethods = Record<string, never>,\n>(\n  enumItems: EnumItem<T, TEnumItemExtension>[],\n  extraExtensionMethods?: (\n    enumItems: EnumItem<T, TEnumItemExtension>[],\n  ) => TExtraExtensionMethods,\n) => {\n  const extensionMethods = buildExtensionMethods<T, TEnumItemExtension>(\n    enumItems,\n  );\n  let extra = {} as TExtraExtensionMethods;\n  if (extraExtensionMethods) {\n    extra = extraExtensionMethods(enumItems);\n  }\n  return { ...extensionMethods, ...extra };\n};\n\n/**\n * Builds all standard extension methods for enum objects.\n * These methods provide various ways to look up, filter, and transform enum items.\n *\n * @internal\n */\nconst buildExtensionMethods = <T, TEnumItemExtension>(\n  rawEnum: EnumItem<T, TEnumItemExtension>[],\n): ExtensionMethods<\n  { [k: string]: EnumItem<T, TEnumItemExtension> },\n  TEnumItemExtension\n> => {\n  return {\n    // Lookup methods - these find enum items by different properties\n\n    fromValue: (target: string) => {\n      const item = Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.value === target,\n      );\n      if (!item) {\n        throw new Error(`No enum value found for '${target}'`);\n      }\n      return item;\n    },\n\n    tryFromValue: (target?: string | null) => {\n      if (!target) {\n        return;\n      }\n      return Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.value === target,\n      );\n    },\n\n    fromKey: (target: string) => {\n      const item = Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.key === target,\n      );\n      if (!item) {\n        throw new Error(`No enum key found for '${target}'`);\n      }\n      return item;\n    },\n\n    tryFromKey: (target?: string | null) => {\n      if (!target) {\n        return;\n      }\n      return Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.key === target,\n      );\n    },\n\n    /**\n     * Flexible lookup by any custom field.\n     * Useful when enum items have additional properties beyond the standard ones.\n     */\n    tryFromCustomField: (\n      field: keyof EnumItem<T, TEnumItemExtension>,\n      target?: string | null,\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n    ) => {\n      if (!target) {\n        return;\n      }\n      return (\n        Object.values(rawEnum)\n          // eslint-disable-next-line unicorn/no-array-callback-reference\n          .filter(filter || (() => true))\n          .find(\n            (value: EnumItem<T, TEnumItemExtension>) => value[field] === target,\n          )\n      );\n    },\n\n    fromDisplay: (target: string) => {\n      const item = Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.display === target,\n      );\n      if (!item) {\n        throw new Error(`No enum display found for '${target}'`);\n      }\n      return item;\n    },\n\n    tryFromDisplay: (target?: string | null) => {\n      if (!target) {\n        return;\n      }\n      return Object.values(rawEnum).find(\n        (value: EnumItem<T, TEnumItemExtension>) => value.display === target,\n      );\n    },\n\n    // Transformation methods - these convert enum items to different formats\n\n    /**\n     * Extract values from a specific custom field across all items.\n     * Respects filter options for empty and deprecated items.\n     */\n    toCustomFieldValues: <CustomFieldType = string>(\n      field: keyof TEnumItemExtension,\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) => {\n      return Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty\n              ? true\n              : notEmpty(x[field] as CustomFieldType)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map(x => x[field] as CustomFieldType);\n    },\n\n    /**\n     * Convert to dropdown options, automatically sorted by index.\n     * Includes optional iconText if present in the enum item.\n     */\n    toOptions: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ): DropdownOption[] => {\n      return [\n        ...((rawEnum as (EnumItem<T, TEnumItemExtension> & {\n          iconText?: string;\n        })[]) || []),\n      ]\n        .sort(\n          (\n            a: EnumItem<T, TEnumItemExtension>,\n            b: EnumItem<T, TEnumItemExtension>,\n          ) => (a?.index && b?.index ? (a?.index || 0) - (b?.index || 0) : 0),\n        )\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map(item => ({\n          label: item.display || item.key,\n          value: item.value,\n          ...(item.iconText ? { iconText: item.iconText } : {}),\n        }));\n    },\n\n    // Array extraction methods - these get arrays of specific properties\n\n    toValues: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) =>\n      Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map((item: EnumItem<T, TEnumItemExtension>) => item.value),\n\n    toKeys: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) =>\n      Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map((item: EnumItem<T, TEnumItemExtension>) => item.key),\n\n    toDisplays: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) =>\n      Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .map(\n          (item: EnumItem<T, TEnumItemExtension>) => item.display,\n        ) as string[],\n\n    toEnumItems: (\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) =>\n      Object.values(rawEnum).filter(\n        x =>\n          (filter ? filter(x) : true) &&\n          (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n          (filterOptions?.showDeprecated ? true : !x.deprecated),\n      ),\n\n    /**\n     * Creates a new object with filtered enum items.\n     * Useful for creating subset enums or when you need an object format.\n     */\n    toExtendableObject: <ITEM_TYPE extends BaseEnum>(\n      filter?: (item: EnumItem<T, TEnumItemExtension>) => boolean,\n      filterOptions?: EnumFilterOptions,\n    ) => {\n      type ExtObject = Record<string, ITEM_TYPE>;\n      return Object.values(rawEnum)\n        .filter(\n          x =>\n            (filter ? filter(x) : true) &&\n            (filterOptions?.showEmpty ? true : notEmpty(x)) &&\n            (filterOptions?.showDeprecated ? true : !x.deprecated),\n        )\n        .reduce((acc: ExtObject, item) => {\n          acc[item.key] = item as unknown as ITEM_TYPE;\n          return acc;\n        }, {} as ExtObject);\n    },\n  };\n};\n","// serializeSmartEnums.ts\nimport { isSmartEnumItem } from '../enumeration.js';\nimport type {\n  SerializedSmartEnums,\n  RevivedSmartEnums,\n  AnyEnumLike,\n} from '../types.js';\n\ntype PlainObject = Record<string, unknown>;\n\nconst isPlainObject = (x: unknown): x is PlainObject =>\n  typeof x === 'object' &&\n  x !== null &&\n  Object.getPrototypeOf(x) === Object.prototype;\n\n// use isSmartEnumItem from enumeration.ts\n\n// Overloads:\n// 1) Inferred\nexport function serializeSmartEnums<T>(input: T): SerializedSmartEnums<T>;\n// 2) Return-type only (constrained to objects/arrays)\nexport function serializeSmartEnums<\n  S extends Readonly<Record<string, unknown>> | readonly unknown[],\n>(input: unknown): S;\n// Implementation\nexport function serializeSmartEnums(input: unknown): unknown {\n  const seen = new WeakMap<object, unknown>();\n\n  const walk = (v: unknown): unknown => {\n    if (isSmartEnumItem(v)) return v.value;\n    if (Array.isArray(v)) {\n      if (seen.has(v)) return seen.get(v);\n      const arr: unknown[] = [];\n      seen.set(v, arr);\n      for (const item of v) arr.push(walk(item));\n      return arr;\n    }\n    if (isPlainObject(v)) {\n      if (seen.has(v)) return seen.get(v);\n      const out: PlainObject = {};\n      seen.set(v, out);\n      for (const [k, val] of Object.entries(v)) {\n        out[k] = walk(val);\n      }\n      return out;\n    }\n    return v;\n  };\n\n  return walk(input);\n}\n\n// Reverse with a simple field->enum map\n// Overloads:\n// 1) Inferred\nexport function reviveSmartEnums<\n  T,\n  const M extends Record<string, AnyEnumLike>,\n>(input: T, enumByField: M): RevivedSmartEnums<T, M>;\n// 2) Return-type only (constrained to objects/arrays)\nexport function reviveSmartEnums<\n  R extends Readonly<Record<string, unknown>> | readonly unknown[],\n>(input: unknown, enumByField: Record<string, AnyEnumLike>): R;\n// Implementation\nexport function reviveSmartEnums(\n  input: unknown,\n  enumByField: Record<string, AnyEnumLike>,\n): unknown {\n  const seen = new WeakMap<object, unknown>();\n\n  const walk = (v: unknown, parentKey?: string): unknown => {\n    if (typeof v === 'string' && parentKey && enumByField[parentKey]) {\n      return enumByField[parentKey].tryFromValue(v) ?? v;\n    }\n    if (Array.isArray(v)) {\n      if (seen.has(v)) return seen.get(v);\n      const arr: unknown[] = [];\n      seen.set(v, arr);\n      for (const item of v) arr.push(walk(item));\n      return arr;\n    }\n    if (isPlainObject(v)) {\n      if (seen.has(v)) return seen.get(v);\n      const out: PlainObject = {};\n      seen.set(v, out);\n      for (const [k, val] of Object.entries(v)) {\n        out[k] = walk(val, k);\n      }\n      return out;\n    }\n    return v;\n  };\n\n  return walk(input);\n}\n"],"mappings":"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","names":[]}